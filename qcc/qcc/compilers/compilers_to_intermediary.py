#!/usr/bin/env python3
from os.path import dirname, realpath, exists
# remove for python 3.6
# from future import annotations

import pyduktape

import qcc.assembly
from qcc.interfaces import Compiler
from qcc.intermediary_lang import IntermediaryProgram


class QASM_Intermediary_Compiler(Compiler):
    """ Compiles QASM to Intermediary Language """

    def __init__(self):
        # Create JS interpreter
        self.js_ctx = pyduktape.DuktapeContext()
        # Load quantum-circuit JS package into JS context
        qc_js = f"{dirname(realpath(__file__))}/dependencies/quantum-circuit.min.js"
        if exists(qc_js):
            self.js_ctx.eval_js_file(qc_js)
        else:
            raise FileNotFoundError("Missing qc.js dependency.")

    def compile(self, source):
        # removed type annotation for python 3.6
        # def compile(self, source: qcc.assembly.QASM): #  -> IntermediaryProgram:
        self.js_ctx.set_globals(qasm=source.program.qasm())
        quil_str = self.js_ctx.eval_js(
            "var circuit = new QuantumCircuit();"
            "circuit.importQASM(qasm);"
            "circuit.exportPyquil('', true, null, '', '', false);"
            )
        # We don't want to run the circuit generated by the JS convervter
        quil_str = quil_str.split("qc = get_qc", 1)[0]
        # p will be overwritten by exec statement
        global p
        p = None
        exec("global p\n" + quil_str)
        quil = qcc.assembly.Quil()
        quil.program = p
        return IntermediaryProgram(quil=quil)


class Quil_Intermediary_Compiler(Compiler):
    """ Compiles Quil to Intermediary Language """

    def __init__(self):
        pass

    def compile(self, source):
        # def compile(self, source: qcc.assembly.Quil) -> IntermediaryProgram
        return IntermediaryProgram(quil=source)
